```python
import board
import busio
import displayio
import terminalio
from adafruit_display_text import label
import i2cdisplaybus
import adafruit_displayio_ssd1306
import time
from rotary_encoder import RotaryEncoder
import digitalio
import adafruit_adxl34x
import math
import neopixel
from rainbowio import colorwheel

# Initialize display
displayio.release_displays()
i2c = busio.I2C(board.SCL, board.SDA)
display_bus = i2cdisplaybus.I2CDisplayBus(i2c, device_address=0x3C)
display = adafruit_displayio_ssd1306.SSD1306(display_bus, width=128, height=64)

# Initialize rotary encoder (CLK=D3, DT=D2)
encoder = RotaryEncoder(board.D3, board.D2, pulses_per_detent=1)

# Initialize button (D1 pin)
button = digitalio.DigitalInOut(board.D1)
button.direction = digitalio.Direction.INPUT
button.pull = digitalio.Pull.UP

# Initialize accelerometer
accelerometer = adafruit_adxl34x.ADXL345(i2c)

# Initialize NeoPixel
pixel_pin = board.D6
num_pixels = 1
pixels = neopixel.NeoPixel(pixel_pin, num_pixels, brightness=0.3, auto_write=False)

# Game states
STATE_SPLASH = 0
STATE_DIFFICULTY_SELECT = 1
STATE_GAME_START = 2
STATE_GAME_PLAYING = 3
STATE_GAME_OVER = 4
STATE_RESULT = 5

current_state = STATE_SPLASH
selected_difficulty = 0
difficulties = ["EASY", "NORMAL", "HARD"]

# Game variables
current_level = 0
score = 0
countdown_time = 0
level_start_time = 0
player_x, player_y = 0, 0
exit_x, exit_y = 0, 0

# Encoder and button state
encoder_position = 0
last_encoder_position = 0
last_encoder_time = 0
encoder_debounce_ms = 80  # Use original program's debounce time
button_pressed = False
last_button_value = button.value

# Direction detection related variables
angle_threshold = 20
duration_threshold = 0.3
direction_start_time = {
    "up": None,
    "down": None, 
    "left": None,
    "right": None
}
last_direction_time = 0
direction_cooldown = 0.5

# Remove selection cooldown time related variables

# Maze maps: First define EASY's 10 levels,
# NORMAL / HARD are automatically generated by transforming EASY
easy_levels = [
    # Level 1
    [
        "########",
        "#S     #",
        "#      #",
        "#      #",
        "#      #",
        "#     E#",
        "########",
    ],
    # Level 2
    [
        "########",
        "#S     #",
        "# ##   #",
        "#      #",
        "#      #",
        "#     E#",
        "########",
    ],
    # Level 3
    [
        "########",
        "#S     #",
        "#  ##  #",
        "#      #",
        "#  ##  #",
        "#     E#",
        "########",
    ],
    # Level 4
    [
        "########",
        "#S     #",
        "# ###  #",
        "#      #",
        "#  ##  #",
        "#     E#",
        "########",
    ],
    # Level 5
    [
        "########",
        "#S     #",
        "#  ##  #",
        "#   #  #",
        "#   #  #",
        "#     E#",
        "########",
    ],
    # Level 6
    [
        "########",
        "#S #   #",
        "#  #   #",
        "#  #   #",
        "#  ##  #",
        "#     E#",
        "########",
    ],
    # Level 7
    [
        "########",
        "#S #   #",
        "#  #   #",
        "#  ##  #",
        "#      #",
        "#    E #",
        "########",
    ],
    # Level 8
    [
        "########",
        "#S     #",
        "# #### #",
        "#      #",
        "#  ##  #",
        "#    E #",
        "########",
    ],
    # Level 9
    [
        "########",
        "#S     #",
        "#  #####",
        "#      #",
        "# #### #",
        "#     E#",
        "########",
    ],
    # Level 10
    [
        "########",
        "#S     #",
        "# ###  #",
        "#   #  #",
        "# ###  #",
        "#     E#",
        "########",
    ],
]

# NORMAL
normal_levels = [
    # Level 1
    [
        "########",
        "#     S#",
        "#      #",
        "#      #",
        "#      #",
        "#E     #",
        "########",
    ],
    # Level 2
    [
        "########",
        "#     S#",
        "#   ## #",
        "#      #",
        "#      #",
        "#E     #",
        "########",
    ],
    # Level 3
    [
        "########",
        "#     S#",
        "#  ##  #",
        "#      #",
        "#  ##  #",
        "#E     #",
        "########",
    ],
    # Level 4
    [
        "########",
        "#     S#",
        "#  ### #",
        "#      #",
        "#  ##  #",
        "#E     #",
        "########",
    ],
    # Level 5
    [
        "########",
        "#     S#",
        "#  ##  #",
        "#  #   #",
        "#  #   #",
        "#E     #",
        "########",
    ],
    # Level 6
    [
        "########",
        "#   # S#",
        "#   #  #",
        "#   #  #",
        "#  ##  #",
        "#E     #",
        "########",
    ],
    # Level 7
    [
        "########",
        "#   # S#",
        "#   #  #",
        "#  ##  #",
        "#      #",
        "#  E   #",
        "########",
    ],
    # Level 8
    [
        "########",
        "#     S#",
        "# #### #",
        "#      #",
        "#  ##  #",
        "# E    #",
        "########",
    ],
    # Level 9
    [
        "########",
        "#     S#",
        "#####  #",
        "#      #",
        "# #### #",
        "#E     #",
        "########",
    ],
    # Level 10
    [
        "########",
        "#     S#",
        "#  ### #",
        "#  #   #",
        "#  ### #",
        "#E     #",
        "########",
    ],
]


# HARD
hard_levels = [
    # Level 1  (easy Level 4)
    [
        "########",
        "#S     #",
        "# ###  #",
        "#      #",
        "#  ##  #",
        "#     E#",
        "########",
    ],
    # Level 2  (easy Level 5)
    [
        "########",
        "#S     #",
        "#  ##  #",
        "#   #  #",
        "#   #  #",
        "#     E#",
        "########",
    ],
    # Level 3  (easy Level 6)
    [
        "########",
        "#S #   #",
        "#  #   #",
        "#  #   #",
        "#  ##  #",
        "#     E#",
        "########",
    ],
    # Level 4  (easy Level 7)
    [
        "########",
        "#S #   #",
        "#  #   #",
        "#  ##  #",
        "#      #",
        "#    E #",
        "########",
    ],
    # Level 5  (easy Level 8)
    [
        "########",
        "#S     #",
        "# #### #",
        "#      #",
        "#  ##  #",
        "#    E #",
        "########",
    ],
    # Level 6  (easy Level 9)
    [
        "########",
        "#S     #",
        "#  #####",
        "#      #",
        "# #### #",
        "#     E#",
        "########",
    ],
    # Level 7  (easy Level 10)
    [
        "########",
        "#S     #",
        "# ###  #",
        "#   #  #",
        "# ###  #",
        "#     E#",
        "########",
    ],
    # Level 8  (harder, new)
    [
        "########",
        "#S     #",
        "# ###  #",
        "#   #  #",
        "### #  #",
        "#     E#",
        "########",
    ],
    # Level 9  (more difficult, new)
    [
        "########",
        "#S #   #",
        "# # ## #",
        "# #  # #",
        "# #### #",
        "#     E#",
        "########",
    ],
    # Level 10 (most difficult, new)
    [
        "########",
        "#S #   #",
        "# ###  #",
        "#   #  #",
        "### #  #",
        "#     E#",
        "########",
    ],
]

# Organized in original structure: 0=EASY, 1=NORMAL, 2=HARD
maze_levels = [
    easy_levels,    # selected_difficulty == 0
    normal_levels,  # selected_difficulty == 1
    hard_levels,    # selected_difficulty == 2
]


# Set level times based on difficulty
level_times = {
    "EASY": 60,
    "NORMAL": 45, 
    "HARD": 30
}

def calculate_angles(x, y, z):
    """Calculate X-axis and Y-axis angles (relative to gravity direction)"""
    angle_x = math.atan2(x, math.sqrt(y*y + z*z)) * 180 / math.pi
    angle_y = math.atan2(y, math.sqrt(x*x + z*z)) * 180 / math.pi
    return angle_x, angle_y

def check_direction(angle_x, angle_y, current_time):
    """Detect if four directions meet conditions"""
    # Check direction movement cooldown
    if current_time - last_direction_time < direction_cooldown:
        return None
    
    direction = None
    
    # Move up (X-axis negative direction)
    if angle_x < -angle_threshold:
        if direction_start_time["up"] is None:
            direction_start_time["up"] = current_time
        elif current_time - direction_start_time["up"] >= duration_threshold:
            direction = "UP"
    else:
        direction_start_time["up"] = None
    
    # Move down (X-axis positive direction)
    if angle_x > angle_threshold:
        if direction_start_time["down"] is None:
            direction_start_time["down"] = current_time
        elif current_time - direction_start_time["down"] >= duration_threshold:
            direction = "DOWN"
    else:
        direction_start_time["down"] = None
    
    # Move left (Y-axis positive direction)
    if angle_y > angle_threshold:
        if direction_start_time["left"] is None:
            direction_start_time["left"] = current_time
        elif current_time - direction_start_time["left"] >= duration_threshold:
            direction = "LEFT"
    else:
        direction_start_time["left"] = None
    
    # Move right (Y-axis negative direction)
    if angle_y < -angle_threshold:
        if direction_start_time["right"] is None:
            direction_start_time["right"] = current_time
        elif current_time - direction_start_time["right"] >= duration_threshold:
            direction = "RIGHT"
    else:
        direction_start_time["right"] = None
    
    return direction

def flash_led(color, times=2, delay=0.3):
    """Flash LED light"""
    for _ in range(times):
        pixels.fill(color)
        pixels.show()
        time.sleep(delay)
        pixels.fill((0, 0, 0))
        pixels.show()
        time.sleep(delay)

def rainbow_cycle(duration=3):
    """Rainbow color cycle"""
    start_time = time.monotonic()
    while time.monotonic() - start_time < duration:
        for j in range(255):
            if time.monotonic() - start_time >= duration:
                break
            pixels[0] = colorwheel(j & 255)
            pixels.show()
            time.sleep(0.01)

# Display group cache to avoid repeated creation
splash_group = None
difficulty_group = None
game_start_group = None
game_group = None
result_group = None

def create_splash_screen():
    """Create splash screen"""
    global splash_group
    if splash_group is None:
        splash_group = displayio.Group()
        title_label = label.Label(terminalio.FONT, text="Maze Run", x=35, y=15, scale=1)
        version_label = label.Label(terminalio.FONT, text="**********", x=30, y=30, scale=1)
        hint_label = label.Label(terminalio.FONT, text="START GAME", x=30, y=45, scale=1)
        splash_group.append(title_label)
        splash_group.append(version_label)
        splash_group.append(hint_label)
    return splash_group

def create_difficulty_screen():
    """Create difficulty selection screen"""
    global difficulty_group
    # Clear old group
    if difficulty_group:
        for _ in range(len(difficulty_group)):
            difficulty_group.pop()
    
    difficulty_group = displayio.Group()
    title_label = label.Label(terminalio.FONT, text="SELECT MODE", x=30, y=10, scale=1)
    difficulty_group.append(title_label)
    
    y_pos = 30
    for i, difficulty in enumerate(difficulties):
        prefix = "> " if i == selected_difficulty else "  "
        diff_label = label.Label(terminalio.FONT, text=f"{prefix}{difficulty}", x=35, y=y_pos, scale=1)
        difficulty_group.append(diff_label)
        y_pos += 15
    
    return difficulty_group

def create_game_start_screen():
    """Create game start screen"""
    global game_start_group
    if game_start_group is None:
        game_start_group = displayio.Group()
    
    # Clear old content
    for _ in range(len(game_start_group)):
        game_start_group.pop()
        
    difficulty_text = f"MODE: {difficulties[selected_difficulty]}"
    diff_label = label.Label(terminalio.FONT, text=difficulty_text, x=20, y=20, scale=1)
    start_label = label.Label(terminalio.FONT, text="GAME START!", x=25, y=40, scale=1)
    back_label = label.Label(terminalio.FONT, text="PRESS TO MENU", x=15, y=55, scale=1)
    game_start_group.append(diff_label)
    game_start_group.append(start_label)
    game_start_group.append(back_label)
    
    return game_start_group

def create_game_screen():
    """Create game playing screen - optimize memory usage"""
    global game_group
    
    # If game group already exists, clear content
    if game_group:
        for _ in range(len(game_group)):
            game_group.pop()
    else:
        game_group = displayio.Group()
    
    # Left information area
    level_text = f"L:{current_level+1}/10"
    time_text = f"T:{int(countdown_time)}"
    score_text = f"S:{score}"
    
    level_label = label.Label(terminalio.FONT, text=level_text, x=5, y=10, scale=1)
    time_label = label.Label(terminalio.FONT, text=time_text, x=5, y=25, scale=1)
    score_label = label.Label(terminalio.FONT, text=score_text, x=5, y=40, scale=1)
    
    game_group.append(level_label)
    game_group.append(time_label)
    game_group.append(score_label)
    
    # Right maze area - use smaller characters and spacing to fit screen
    maze = maze_levels[selected_difficulty][current_level]
    
    # Maze drawing area parameters - adjusted to fit screen
    cell_size = 6  # Reduce cell size
    start_x = 65   # Start from right side of screen
    start_y = 5    # Start from top
    
    # Only draw visible maze portion
    for row in range(min(len(maze), 7)):  # Display at most 7 rows
        for col in range(min(len(maze[0]), 8)):  # Display at most 8 columns
            x_pos = start_x + col * cell_size
            y_pos = start_y + row * cell_size
            
            # Draw maze elements
            cell_char = maze[row][col]
            if cell_char == '#':  # Wall
                char_label = label.Label(terminalio.FONT, text="#", x=x_pos, y=y_pos, scale=1)
                game_group.append(char_label)
            elif cell_char == 'S':  # Start point
                char_label = label.Label(terminalio.FONT, text="P", x=x_pos, y=y_pos, scale=1)
                game_group.append(char_label)
            elif cell_char == 'E':  # End point
                char_label = label.Label(terminalio.FONT, text="E", x=x_pos, y=y_pos, scale=1)
                game_group.append(char_label)
            else:  # Path
                char_label = label.Label(terminalio.FONT, text=".", x=x_pos, y=y_pos, scale=1)
                game_group.append(char_label)
            
            # Draw selection box (if current position is player position)
            if row == player_y and col == player_x:
                # Draw brackets around selection box
                box_left = label.Label(terminalio.FONT, text="[", x=x_pos-2, y=y_pos, scale=1)
                box_right = label.Label(terminalio.FONT, text="]", x=x_pos+3, y=y_pos, scale=1)
                game_group.append(box_left)
                game_group.append(box_right)
    
    return game_group

def create_result_screen(is_victory):
    """Create result screen"""
    global result_group
    
    # If result group already exists, clear content
    if result_group:
        for _ in range(len(result_group)):
            result_group.pop()
    else:
        result_group = displayio.Group()
    
    result_text = "VICTORY!" if is_victory else "GAME OVER"
    result_label = label.Label(terminalio.FONT, text=result_text, x=35, y=10, scale=1)
    score_label = label.Label(terminalio.FONT, text=f"SCORE: {score}", x=35, y=25, scale=1)
    
    # Button selection
    buttons = ["RESTART", "MAIN MENU"]
    y_pos = 40
    for i, btn in enumerate(buttons):
        prefix = "> " if i == selected_difficulty else "  "
        btn_label = label.Label(terminalio.FONT, text=f"{prefix}{btn}", x=20, y=y_pos, scale=1)
        result_group.append(btn_label)
        y_pos += 15
    
    result_group.append(result_label)
    result_group.append(score_label)
    
    return result_group

def load_level(level_index):
    """Load specified level"""
    global player_x, player_y, exit_x, exit_y, level_start_time, countdown_time
    
    maze = maze_levels[selected_difficulty][level_index]
    
    # Find start point (S) and end point (E)
    for y, row in enumerate(maze):
        for x, cell in enumerate(row):
            if cell == 'S':
                player_x, player_y = x, y
            elif cell == 'E':
                exit_x, exit_y = x, y
    
    level_start_time = time.monotonic()
    countdown_time = level_times[difficulties[selected_difficulty]]

def move_player(direction):
    """Move player"""
    global player_x, player_y, last_direction_time
    
    new_x, new_y = player_x, player_y
    
    if direction == "UP":
        new_y -= 1
    elif direction == "DOWN":
        new_y += 1
    elif direction == "LEFT":
        new_x -= 1
    elif direction == "RIGHT":
        new_x += 1
    
    # Check boundaries and walls
    maze = maze_levels[selected_difficulty][current_level]
    if (0 <= new_x < len(maze[0]) and 
        0 <= new_y < len(maze) and 
        maze[new_y][new_x] != '#'):
        player_x, player_y = new_x, new_y
        last_direction_time = time.monotonic()
        return True
    return False

def check_level_complete():
    """Check if level is completed"""
    return player_x == exit_x and player_y == exit_y

# Initial display
display.root_group = create_splash_screen()

print("Game Starting...")

# Main loop variables
last_display_update = 0
display_update_interval = 0.5  # Increase display update interval to reduce flickering

while True:
    current_time = time.monotonic()
    current_ms = current_time * 1000
    
    # Check rotary encoder - use original program's simple logic
    encoder_changed = encoder.update()
    if encoder_changed:
        if current_ms - last_encoder_time > encoder_debounce_ms:
            encoder_position = encoder.position
            last_encoder_time = current_ms
    
    # Check button
    current_button_value = button.value
    if last_button_value and not current_button_value:
        button_pressed = True
        print("Button pressed!")
    last_button_value = current_button_value
    
    # State machine processing
    if current_state == STATE_SPLASH:
        if button_pressed:
            current_state = STATE_DIFFICULTY_SELECT
            encoder_position = 0
            last_encoder_position = 0
            display.root_group = create_difficulty_screen()
            print("State changed: SPLASH -> DIFFICULTY_SELECT")
            button_pressed = False
    
    elif current_state == STATE_DIFFICULTY_SELECT:
        # Handle encoder rotation to select difficulty - use original program's simple logic
        if encoder_position != last_encoder_position:
            # Whether clockwise or counterclockwise, switch to next difficulty
            selected_difficulty = (selected_difficulty + 1) % len(difficulties)
            
            # Update display
            display.root_group = create_difficulty_screen()
            print(f"Difficulty selected: {difficulties[selected_difficulty]}")
            last_encoder_position = encoder_position
        
        # Handle button confirmation
        if button_pressed:
            current_state = STATE_GAME_START
            display.root_group = create_game_start_screen()
            print(f"State changed: DIFFICULTY_SELECT -> GAME_START")
            button_pressed = False
    
    elif current_state == STATE_GAME_START:
        if button_pressed:
            # Initialize game variables
            current_level = 0
            score = 0
            load_level(current_level)
            current_state = STATE_GAME_PLAYING
            display.root_group = create_game_screen()
            print("State changed: GAME_START -> GAME_PLAYING")
            button_pressed = False
    
    elif current_state == STATE_GAME_PLAYING:
        # Update countdown
        elapsed_time = current_time - level_start_time
        countdown_time = max(0, level_times[difficulties[selected_difficulty]] - elapsed_time)
        
        # Reduce display update frequency to avoid flickering
        if current_time - last_display_update > display_update_interval:
            display.root_group = create_game_screen()
            last_display_update = current_time
        
        # Check if time's up
        if countdown_time <= 0:
            current_state = STATE_GAME_OVER
            flash_led((255, 0, 0), 2)  # Red flash
            selected_difficulty = 0  # For result screen button selection
            display.root_group = create_result_screen(False)
            print("Game Over - Time's up!")
            continue
        
        # Get accelerometer data and handle direction control
        x, y, z = accelerometer.acceleration
        angle_x, angle_y = calculate_angles(x, y, z)
        direction = check_direction(angle_x, angle_y, current_time)
        
        # Handle direction movement
        if direction:
            print(f"Moving: {direction}")
            if move_player(direction):
                # Update display immediately after movement
                display.root_group = create_game_screen()
                last_display_update = current_time  # Reset display update timer
        
        # Check if reached exit
        if button_pressed:
            if check_level_complete():
                # Complete level
                score += 10
                current_level += 1
                
                if current_level >= 10:
                    # All levels completed
                    current_state = STATE_RESULT
                    rainbow_cycle(3)  # Rainbow flash for 3 seconds
                    selected_difficulty = 0
                    display.root_group = create_result_screen(True)
                    print("All levels completed!")
                else:
                    # Enter next level
                    flash_led((0, 255, 0), 2)  # Green flash
                    load_level(current_level)
                    display.root_group = create_game_screen()
                    last_display_update = current_time  # Reset display update timer
                    print(f"Level {current_level} completed! Moving to level {current_level + 1}")
            else:
                print("Not at exit position")
            
            button_pressed = False
    
    elif current_state == STATE_GAME_OVER:
        # Handle result screen button selection - use original program's simple logic
        if encoder_position != last_encoder_position:
            # Whether clockwise or counterclockwise, switch to next option
            selected_difficulty = (selected_difficulty + 1) % 2
            
            display.root_group = create_result_screen(False)
            last_encoder_position = encoder_position
        
        if button_pressed:
            if selected_difficulty == 0:  # RESTART
                current_state = STATE_GAME_START
                display.root_group = create_game_start_screen()
            else:  # MAIN MENU
                current_state = STATE_SPLASH
                display.root_group = create_splash_screen()
            button_pressed = False
    
    elif current_state == STATE_RESULT:
        # Handle victory result button selection - use original program's simple logic
        if encoder_position != last_encoder_position:
            # Whether clockwise or counterclockwise, switch to next option
            selected_difficulty = (selected_difficulty + 1) % 2
            
            display.root_group = create_result_screen(True)
            last_encoder_position = encoder_position
        
        if button_pressed:
            if selected_difficulty == 0:  # RESTART
                current_state = STATE_GAME_START
                display.root_group = create_game_start_screen()
            else:  # MAIN MENU
                current_state = STATE_SPLASH
                display.root_group = create_splash_screen()
            button_pressed = False
    
    time.sleep(0.05)
```
